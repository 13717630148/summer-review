# 计算机程序设计基础(1) C++复习

#### 1. C++相比较与C语言增加了哪些机制？
+ C++：**面向对象**的程序设计语言
+ C++增加的最重要的机制(3个):
	- 类
	- 函数重载
	- 操作符重载
+ C++引入了新的数据类型：bool变量：true和false
+ C++的输入cin和输出cout
	- 引用头文件
		\#include <iostream>
		\#using namespace std;
	- 常用的I/O流类操作函数：
		* 引用iomanip：\#include <iomanip>
		* setw：设置场宽
		* setprecision：设置输出的浮点数位数
		* hex/oct/dec：十六、八、二进制输出
+ C++的内联函数：
	- 目的：提高执行效率
	- 与define类似，将出现函数名的位置用函数体替换
+ C++动态内存分配:
	- 内存申请：new
		int *p = new int(10);//分配一个内存单元，赋初值为10
		int *pt = new int[10];//分配10个int单元
		int **q = new int*[10];//分配10个int指针单元
	- 内存释放：delete
		delete p;
		delete []pt;
		delete []q;
+ C++提供了传递变量地址的机制
	- C的参数传递只是传值
	- C++在函数头中要传地址的变量前增加&--引用
	- 引用：一种特殊类型的变量，可以认为给变量起别名
	- 优点：
		* 简化程序书写
		* 提高程序执行效率
		* 类的复制构造函数使用引用方式传变量地址
+ C++提供类型修饰符const
	- const：不可修改的量，不能给该变量赋值
		void swap(int &a, const int &b){……}
		const A = {, , ,} //常对象
+ C++的作用域与可见性
	- C语言有局部变量和全局变量
	- C++为了实现能够同时访问同名的局部变量和全局变量
		* 作用域操作符 ::
+ C++的缺省函数：
	- 函数声明中，为一个或多个参数指定缺省值
+ C++的数据抽象：模板操作
	- 数据抽象：将数据类型与操作分开
	- 栈操作：操作时不考虑对象的类型
	- 模板：适用于任何数据类型的栈操作


#### 2. C++中的函数重载解释？

+ 函数重载：
	- 定义：
		* 允许函数名相同
		* 对函数返回值类型是否相同没有要求
		* **函数参数类型和个数不能完全一样**
	- 编译系统通过静态绑定**确定函数到底是哪个**：
		* 函数参数个数不同时，由参数个数决定
		* 参数个数相同时，由实参类型决定
		* 如果找不到个数相同、实参类型也相同的函数，系统提示出错
	- **调用二义性**函数重载与缺省函数：
		* 函数1：double f(double x)
		* 函数2：double f(double x, double y=0)
		* 函数2有缺省值，因而调用f(1.0)时编译会出错，对重载函数的调用不明确

#### 3. C++中类的说明及组成？类有什么特性？

+ 关于类的说明：
	- 类是对象的抽象，对象是类的实例。
	- 类是抽象的，不占用内存
	- 类不是类型，是对数据和数据操作函数的封装
+ 类的成员及成员函数：
	- 成员变量：
		* 私有成员：private
		* 公有成员：public
	- 成员函数：主函数只能通过成员函数间接访问类的私有成员
	- 构造函数/析构函数：
		* 构造函数：与类同名的函数(只能隐式自动调用)
		* 析构函数：~+类名的函数(只能隐式自动调用)
		* 程序员未定义两个函数时，编译器自动生成两个函数
		* **注意**：析构的顺序与构造的顺序完全相反、一一对应！
	- 内联构造函数：
		* 构造函数前加inline
		* 或函数体放在类内，自动成为内联构造函数
	- 复制构造函数：
		* 特殊的构造函数：形参是类对象的引用
		* 作用：使用已经存在的对象，构造并初始化同类的新对象
		* 浅复制：两个变量指向同一块内存，结构体整体赋值属于浅复制
		* 深复制：对对象指针变量所指的内存申请新的内存，并进行赋值
	- 常成员函数：
		* 函数名()之后添加修饰符const
		* mutable关键字，在常成员函数中给特定成员变量可以修改的功能：在定义前增加mutable
	- 静态成员：
		* 功能：在多个对象之间共享数据、传递信息
		* 静态成员在整个程序中只有一个
		* 不同类的不同对象访问唯一的一个静态成员
		* 静态成员函数：只存取静态成员，在整个程序中也只有一个
+ 类的一些重要特性：
	- 友元机制；
		* 功能：让不是本对象成员函数的其他函数能够直接访问私有成员
		* 友元函数必须在类中依次列出
		* 注意：
			+ 友元关系不能被继承。 
            + 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元
            + 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元
	- 嵌套类：
		* 在一个类A中声明另一个类B
		* 使用B类需要增加前缀变为A::B
	- 类的前向引用：有些类未先定义就被其他类调用，因而需要提前声明一下类的符号
	- 类的this指针：
		* 成员函数可以访问到对象本身
		* this指针指向该成员函数正在操作的对象
		* this指针只能在成员函数内调用
		* this指针不能被更新，属于**常指针**
	- 类的组合；
		* 类的成员数据是另一个类的对象
		* 类的构造函数先执行内嵌对象的构造函数，在执行本类的构造函数，析构顺序与此相反
	- 类的实例：对象、静态对象数组、动态对象数组(new)
		* new：申请动态对象，触发类的构造函数
		* delete：释放动态内存，触发类的析构函数

#### 4. C++类有什么重要应用？什么是操作符重载？

+ 单链表：
	- 特点：
		* 每个元素由结点构成
		* 具有线性结构
		* 结点可以不连续存储
		* 单链表具有扩充性
	- 单链表类的定义：
		* 链表结点类：ListNode
		* 链表类
+ 操作符重载：
	- 定义：C++允许将原来的操作符加入新的含义
	- 原则：
		* 操作符必须已有，不能自己定义
		* 操作符重载不能改变原运算符的运算优先级和操作数个数
		* 可重载的操作符：45个
		* 不可重载的操作符：5个：.、.*、::、?:、sizeof
	- 编译系统对重载运算符的选择：
		* 操作对象的类型决定操作符的语义
	- 操作符重载函数由两种形式：	
		* 重载为类的成员函数：形参个数是操作符操作数个数减1
		* 重载为类的友元函数：形参个数与操作符操作数相同
	- 提高执行效率：将重载运算符函数的参数改为引用方式，减少函数调用，可以加上const修饰符避免引用的副作用
	- 单目操作符的友元函数：将++操作符的友元函数参数改为非引用方式
	- 特殊操作符的重载：
		* ＝：默认的=是浅复制，如果想要深复制，需要对=进行操作符重载
		* <<：C语言为左移，C++重载为流插入运算符，用于输出；重载是只能将<<和>>重载为类的友元函数，并且参数和返回值都必须是引用方式
	- 强制类型转换：先进行类型的强制转换，再进行运算
	- C++的参数传递与C语言同样是自右向左

#### 5. C++如何实现类的继承和派生？

+ 定义：
	- 继承：保持已有类的特性而构造新类
	- 派生：在已有类的基础上新增自己的特性
+ 优点：
	- 自动为一个类提供来自另一个类的操作和数据结构
	- 重用利用已有的资源，实现代码复用
+ 类的继承
	- 三种继承方式：
		* 公有继承
		* 保护继承
		* 私有继承
		class Rectangle:public Shape{……}
	- 继承的访问控制：
		* 公有继承：派生类的成员函数只能访问基类中具有公有访问特性的成员或成员函数
		* 私有继承：基类的任何性质的成员都是派生类的私有成员；派生类的成员函数可以直接访问基类的公有和保护成员
	- 保护成员：protected
		* 对于基类，类似与private
		* 对于派生类，类似于public
		* 派生类可以直接访问基类的保护成员，但不能直接访问基类的私有成员
		* 除了派生类其他类不能直接访问A的保护成员
	- 友元与继承:
		* 将派生类声明为基类的友元，则可以直接访问基类的私有成员
	- 成员名限定：
		* 派生类和基类可以声明同名的成员，在派生类中访问时，编译器默认是派生类的成员