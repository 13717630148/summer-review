# 操作系统 知识梳理

## 引论概述

#### 1. 计算机系统的组成？为什么引入操作系统？什么是操作系统？操作系统有哪些功能和作用？操作系统的硬件环境？

+ 计算机组成：
	- 硬件：物理设备的有机组合，系统赖以工作的实体
	- 软件：程序和文件的集合。程序是计算任务的处理对象和处理规则的描述；文件是需要的资料数据
+ 引入操作系统的原因：
	- 计算机硬件复杂，直接对硬件编程不现实
+ 操作系统的定义：
	- 最基本的系统软件

	![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P01.png?token=AYGNCH03C4TceOmOJYkVfEkBV6gbhMhLks5Znr3bwA%3D%3D)

	- 特点：
		* 有效：系统效率和资源利用率
		* 合理：是否公平
		* 方便：提供良好的、一致的用户接口
+ 操作系统的功能：
	- 将硬件的复杂性与程序分离
	- 在裸机上加载一层软件，给用户提供更容易理解和编程的接口
	- 控制计算机的所有资源，提供开发应用程序的基础
+ 操作系统的作用：
	- 扩展机器或虚拟机，更容易编程和使用
	- 资源管理者，管理CPU、存储器、外部设备等
		* 跟踪资源使用状况
		* 满足资源请求
		* 提高资源利用率
		* 协调各程序和用户对资源的使用冲突
	- 用户使用计算机软硬件的接口
		* 系统命令
		* 系统调用
+ 操作系统的历史：
	- 电子管时代
	- 晶体管时代
		* 批处理操作系统
	- 集成电路时代
		* 多道程序设计：宏观并行微观串行
		* 分时系统
		* 系列机思想
	- 大规模集成电路时代
		* 个人计算机操作系统
		* 分布式操作系统
		* 嵌入式操作系统：对嵌入式芯片及各种资源同一协调、控制
+ 操作系统的硬件环境：
	- 处理器
		* 运算器、控制器、寄存器和高速缓存
		* 取指、译码、执行
		* 核心态和用户态：
			+ 核心态：操作系统管理程序运行
			+ 用户态：用户程序运行时的状态
		* 处理器如何知道当前运行的是操作系统还是一般软件：
			+ CPU的工作状态码
		* CPU状态的转换：
			+ 用户态→核心态：嵌入
			+ 核心态→用户态：修改程序状态字
	- 存储器
		* 存储程序和数据
		* 三因素：容量、速度和成本
		* 层次化存储体系结构+局部性原理
	- I/O设备
		* 控制器+设备
		* 设备驱动程序：专门与控制器对话
		* 编址方式：存储映像编址、IO独立编址
		* 控制方式：轮询、中断驱动IO、直接存储器访问(DMA)
		* 中断响应：

		![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P02.png?token=AYGNCCAlkq7Lq3jM69F52J2hCP0QmI_fks5Znr3qwA%3D%3D)

		* 中断提高处理器处理IO的效率，但是传送大量数据时效率仍不高
		* DMA控制器自动控制成块数据在内存和IO设备间的传送
	- 总线

#### 2. 系统调用？
+ 意义：
	- 方便用户编写应用程序
	- 在应用程序与系统控制的资源和提供的服务间实现交互作用
	- 动态请求和释放系统资源，完成与硬件相关的工作和控制程序的执行
+ 系统调用的处理过程：
	- 陷入指令
		* 将系统转入核心态
		* 陷入指令中包含对应系统调用的功能号
		* 陷入处理机构将陷入指令功能号与入口地址表对应，调用有关子程序
	- 过程：
		* 系统调用处理前，陷入处理机构保护处理现场
		* 陷入指令调用系统功能
		* 系统调用的功能号驱动有关子程序执行
		* 执行结束后恢复处理机现场，保护在特定内存区或寄存器


#### 3. 操作系统结构有哪些类型？
+ 单体系统
	- 优点：结构紧密，接口简单直接，系统效率高
	- 缺点：
		* 模块间转接随便
		* 数据基本上作为全程量处理
		* 常常关中断，系统的并发性难以提高
+ 分层系统
	- 分解成功能单一的模块，各之间有清晰的组织结构和依赖关系
	- 优点：
		* 更高的可读性和可适应性
		* 便于修改扩充
+ 虚拟机结构
+ 微内核结构：
	- 微内核：运行在核心态下，提供最基本的中断处理、处理机调度、进程间通信功能
	- 优点：机制与策略分离，可靠灵活
	- 缺点：效率低
	- 变体：客户-服务器模型


## 进程与线程

#### 4. 进程的定义和描述？进程的状态有哪些？

+ 程序的顺序执行和并发执行
	- 顺序执行：
		* 顺序性：指定顺序
		* 封闭性：独占所有资源
		* 可再现性：初始条件相同则结果相同
	- 并发执行：提高资源利用率，目前主流操作系统为并发执行
		* 间断性
		* 失去封闭性：共享资源
		* 失去可再现性
+ 进程的引入：为了跟踪与描述程序的并发执行
	- 目的：
		* 为了描述程序在并发执行时对系统资源的共享
		* 描述程序执行时的动态特征
		* 提高资源利用率和系统吞吐量
	- 并发执行的程序：
		* 一个程序在不同数据上的执行
		* 不同程序在不同数据上的执行
+ 进程：
	- 系统进行资源分配和调度的独立单位
	- 特征：
		* 动态性
		* 独立性：地址空间相互独立
		* 并发性
		* 异步性
		* 交互性
		* 结构化
	- 进程的组成：程序+数据+进程控制块
	- 进程与程序的区别

	![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P03.png?token=AYGNCCosY3DSpzWFEWgzyjnKA6FwXyk0ks5Znr0kwA%3D%3D)

+ 进程控制块：
	- Process Control Block, PCB
	- 目的：为了控制和管理进程，用来记录进程外部特征
	- 进程与PCB之间一一对应
	- PCB包含的内容：
		* 描述进程的信息
		* 用于控制进程的信息
		* 资源占用的信息
		* CPU现场保护的信息
	- PCB表：进程表
		* 将所有PCB组织在一起
		* 表的大小决定了系统中最多可能存在的进程个数**系统的并发度**
	- PCB表组织方式：
		* 链接结构
		* 索引结构
+ 进程上下文：对进程执行活动全过程的静态描述
	- 用户级上下文
	- 寄存器级上下文
	- 系统级上下文
+ 进程的状态
	- 三状态模型：运行、就绪、阻塞
	- 五状态模型：+ 新建、终止
	- 七状态模型：五状态模型+就绪挂起+阻塞挂起
		* 挂起：将进程从内存转到外存
	- 补充：Linux五中进程状态
		* 可运行态+浅度睡眠态+暂停状态+僵死状态
+ 进程的控制
	- 定义：操作系统创建和撤销进程，完成进程状态的转换
	- 目的：多个进程高效率并发执行和协调，实现资源共享
	- 方式：根据用户命令和系统的状态
	- 原语：
		* 若干指令构成的原子操作，不可分割
		* 系统调用不都是原语
		* 类型：创建、终止、撤销、阻塞、唤醒等原语

#### 5. 线程和线程的实现机制？

+ 引入线程的目的：
	- 减少程序并发执行付出的时空开销，进一步提高系统并发程度
+ 进程的基本属性(并发执行的基础)：
	- 资源分配单位
	- CPU调度单位
+ 进程的缺点：
	- 系统对进程的时空开销较大
	- 系统中并发执行的进程的数目不宜过多
	- 继承切换速率不宜过高，限制了系统的并发程度
+ 改进进程的缺点：将两个基本属性分离：
	- 进程：只作为资源分配的单位
	- **线程**：作为CPU调度的单位
	- 线程有时被称为轻量级进程
+ 线程的组成：
	- 线程状态、寄存器上下文、线程的栈
	- 基本状态：就绪、运行、阻塞
+ 多线程：同一个进程中允许多个线程
	- 线程共享进程的地址空间和资源
	- 同一进程的每个线程有自己的栈
+ 引入线程的优缺点：
	- 优点：
		* 减少并发执行时间和空间开销
		* 允许在系统中建立更多的线程提高并发程度
		* 同一进程的线程共享内存和文件，相互通信无须调用内核
	- 缺点：在程序设计模型中引入了一定的复杂度
+ 进程与线程比较：
	- 地址空间和其他资源：
		* 进程：进程之间相互独立
		* 线程：同一进程的线程之间共享
		* 某进程的线程在另一进程中不可见
	- 通信：
		* 进程间通信
		* 线程之间：直接读写
	- 调度：
		* 线程上下文切换 快于 进程上下文切换
+ 线程的实现机制：
	- 用户级线程
		* 操作系统内核不知道用户级线程的存在
		* 用户级线程切换不需要核心态特权
		* 每个进程有专用的线程表，记录各线程状态和属性
		* 线程表由线程库(运行时系统)管理
		* 用户级线程的内核活动
			+ 调用系统调用时，线程所在的整个进程阻塞
			+ 线程的状态与进程状态是独立的
		* 优点：
			+ 不需要调用操作系统内核
			+ 调度是应用程序特定的
		* 缺点：
			+ 大多数系统调用阻塞，因而内核阻塞进程后，所有线程都被阻塞
			+ 同一进程的两个线程不能同时运行于两个处理器
	- 内核级线程
		* 操作系统内核维护内核级线程上下文
		* 内核级线程切换需要操作系统内核支持
		* 没有线程库，所有内核级线程由操作系统内核管理，不需要线程库和线程表
		* 内核级线程的调度以线程为基础
		* 优点：
			+ 内核可以同时调度同一进程多个线程
			+ 阻塞是在线程一级完成的
		* 缺点：
			+ 同一进程内的线程切换需要操作系统内核支持，这会导致速度的下降
	- 内核级和用户级混合
		* 将用户级线程与内核级线程多路复用
+ 线程的状态：
	- Windows：就绪、备用、运行、等待、过渡、终止、初始化
	- Linux：只有进程没有线程概念，线程=共享资源的进程

#### 6. 进程之间如何通信？
+ 进程间的关系：
	- 竞争：相互竞争系统中有限的资源
	- 同步：相互协作运行用户的作业
	- 通信：通过通信进行协作
+ 进程间通信问题：
	- Inter Process Communication, IPC
	- 1. 一个进程如何把信息传递给另一个进程
	- 2. 保证对共享资源的访问不会引起冲突
	- 3. 保证正确的操作顺序
	- 总结为：**高级通信问题+互斥与同步问题**
+ 进程间通信的关键：
	- 竞争条件：多个进程访问共享资源时取决于进程运行的时序
	- 临界资源：多个进程访问共享资源时必须互斥地进行
		* 不是所有共享资源都是临界资源，如只读数据
	- 临界区：进程中访问临界资源的代码段
		* 进入区→临界区→退出区→剩余区
+ 解决互斥问题：
	- 要求：
		1. 任何两个进程不能同时处于临界区 
		2. 不应对 CPU 的速度和数量做任何假设
		3. 临界区外运行的进程不得阻塞其他进程
		4. 不得使进程无限期等待入临界区
	- 目的：
		- 避免竞争条件
		- 保证使用临界资源的进程能正确高效地协作
+ 解决互斥问题的方法/算法：
	- 禁止中断：
		* CPU只有在时钟中断或其他中断时才进行进程切换
		* 所以在进入临界区之后禁止中断，就无法进行进程的切换，保证互斥
		* 优点：简单
		* 缺点：
			+ 把禁止中断的权利交给用户进程→系统可靠性较差
			+ 不适用于多处理器
	- 锁变量：
		* 用一个变量表示是否有进程在临界区
		* 缺点；忙等待，可能出现两个进程同时处于临界区
		* 忙等待：连续测试一个变量，直至出现某个值
	- 严格轮转法：记录哪个进程进入临界区
		* 缺点：临界区外进程可能阻塞其他进程，忙等待
	- Peterson算法：
		* 进入临界区前，调用一个函数，判断是否能安全进入
		* 从临界区退出后，调用退出函数，允许其他进程进入临界区
		* 优点：解决互斥访问的问题，克服了严格轮转法缺点
		* 缺点：忙等待
	- 硬件指令算法：
		* 优点：
			+ 适用于任意数目的进程
			+ 容易验证正确性
			+ 支持进程中存在多个临界区，每个临界区设置一个布尔变量
		* 缺点：忙等待
	- 信号量：
		* 高于进程的管理者，解决共有资源使用问题
		* 每个信号量包含一个整数值和一个进程等待队列
		* P、V原语：P申请一个资源，V释放一个资源，PV必须成对使用
		* 为临界资源设置一个互斥信号量，临界区代码位于P和V原语之间
		* 缺点：
			+ 同步操作分散
			+ 易读性差
			+ 不利于修改和维护
			+ 正确性难以保证
	- 管程：
		* 基本思想：把信号量和操作原语封装在一个对象内部
		* 管程的共享变量在管程外部不可见
		* 优点：
			+ 提高代码可读性
			+ 便于修改和维护
			+ 正确性易于保证
		* 缺点：C及多数语言不支持管程
	- 消息传递：
		* 不同机器间的进程通信
		* 经典IPC问题：
			+ 哲学家进餐
			+ 读着写者
			+ 睡眠理发师
+ Windows的互斥和同步机制：
	- 互斥对象：Mutex
	- 信号量对象：Semaphore
	- 事件对象：Event
	- 临界区对象
	- 互锁变量访问
+ POSIX的互斥和同步机制：
	- 互斥锁
	- 条件变量
	- 信号量
+ Linux进程间通信
	- 管道(无名管道/匿名管道)
		* 进程之间相互通信，通常需要两个管道
		* 命名管道，首先写入数据的是首先被读出的数据
	- 消息队列
	- 信号量
	- 共享内存
+ Windows进程间通信：
	- 共享内存
	- 管道
	- 邮件槽mailslot
	- 套接字

#### 7. 什么是死锁问题？如何解决死锁问题？
+ 死锁：系统中多个进程无限制地等待永远不会发生的条件
+ 原因：
	- 对互斥资源的共享
	- 并发执行的顺序不当
	- 双方在同时等待
		1. 对方已经占有的资源
		2. 对方生成资源
	- 必要条件(死锁一定同时满足四个条件)
		1. 互斥
		2. 请求和保持
		3. 非强制剥夺
		4. 环路等待
+ 可抢占资源：存储器/不可抢占资源：打印机
+ 解决死锁问题的方法：
	- 鸵鸟算法：假装危险不存在
	- 死锁预防：预先静态分配、**有序**资源使用
	- 死锁检测：检测是否存在**循环等待**
	- 死锁避免：
		* 银行家算法

#### 8. 处理机调度是什么？不同的系统如何实现调度？
+ 调度：多个进程竞争处理机资源，操作系统选择给哪一个进程分配处理器
+ 处理器调度的层次：
	- 高级调度：作业
	- 中级调度：内外存交换
	- 低级调度：进程或线程
+ 进程调度的算法
	- 批处理系统
		* 目标：吞吐量、周转时间、CPU利用率
		* 先来先调度：有利于长作业、CPU密集作业
		* 最短作业优先：不利于长作业
		* 最短剩余时间优先：有利于短作业
	- 交互式系统
		* 目标：响应时间、均衡性
		* 时间片轮转：所有进程同等重要的假设
		* 优先级调度
		* 多级队列：高优先级队列时间片短
		* 最短进程优先
		* 保证调度：保证**进度慢**的进程
		* 彩票调度：随机选择有彩票的进程
		* 公平分享调度：按进程数对用户调度资源
	- 实时系统
		* 满足截止时间、可预测性
			+ 硬实时、软实时
		* 可调度的条件
		* 速率单调调度：调度优先级最高，必要时剥夺进程
		* 最早截止时限优先
		* 最小裕度算法：选富裕时间最小的
+ 进程调度的时机

![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P04.png?token=AYGNCBvuaNSWaFY3TVJxxJaZiA2UlfGIks5Znr0_wA%3D%3D)

+ 线程的调度：
	- 用户级：由用户级线程库的线程调动程序负责
	- 内核级：由内核选择，不考虑线程属于哪个进程

## 存储管理

#### 9. 什么是存储管理？存储管理有哪些功能？如何将程序装入内存？

+ 存储器的访问局部性原理：
	- 时间上的局部性
	- 空间上的局部性
+ 存储管理的功能：针对内存和外存，主要是内存管理
	- 存储器的分配和回收
		* 调入策略：用户程序在何时调入内存
			+ 请求调页：只调入发生缺页所需的页面
			+ 预先调页：预先调入页面
		* 放置策略：确定用户程序应放置在何处
		* 置换策略：调入新程序时哪些程序可以从内存中移除
		* 分配结构：
			+ 空闲分区表
			+ 空闲分区队列
		* 存储分配和回收的时机：进程的开始和结束
	- 地址变换与重定位
		- 内存每个存储单元都对应一个物理地址
		- 物理地址集合→物理地址空间
		- 逻辑地址：用户编程所用的地址
		- 地址变换：将用户程序的逻辑地址转换为**运行时由机器直接寻址**的物理地址
			* 逻辑地址→物理地址
	- 存储保护
		- 方案1：设置下限寄存器和上限寄存器
		- 方案2：设置基址寄存器和限长寄存器
		- 硬件判断是否越界，越界会产生越界中断，用于存储保护
		- 共享：是存储保护功能的增强，允许多个进程访问内存的同一部分
	- 存储器扩充
		- 应用程序：
			* 覆盖技术：将程序分割，一段结束时调入另一个覆盖块
		- 操作系统：
			* 交换技术：内存某些进程移动至外存(分时系统)
			* 虚拟存储器技术：
				+ 将程序正在使用的部分内容放在内存
				+ 暂时不用的部分放在外存
				+ 在需要时由系统调入内存，并将不需要(或暂不需要)的部分调出内存
+ 程序的装入：
	- 程序执行的步骤：
		* 编译：编译成若干目标模块
		* 链接：将目标模块和所需库函数链接在一起，形成装入模块
		* 装入：装入程序将装入模块装入主存(内存空间)
	- 装入的方法：
		* 绝对装入：直接定位在可执行文件记录的内存地址
			+ 缺点：依赖硬件结构，不适合多道程序系统
		* 可重定位装入：根据定位的内存地址修改重定位地址项
		* 动态装入：把地址转换推迟到真正执行时
			+ 优点：**虚拟存储的基础**，有利于实现共享
			+ 缺点：实现复杂，需要硬件支持

#### 10. 单一连续区存储管理如何实现？分区存储管理呢？
+ 单一连续区存储管理：
	- 无交换分页的单道程序设计
		* 优点：易于管理
		* 缺点：程序全部装入，造成内存浪费
+ 分区存储管理：
	- 将内存分区，操作系统占用其中一个分区
	- 问题：可能存在内碎片、外碎片
	- 两种方法：
		* 固定分区：固定大小的连续分区
			+ 无外碎片，可能有内碎片
			+ 缺点：程序很小时，很可能需要将整个分区分配给它，内碎片较大
		* 动态分区：分区大小数量和位置随着进程而变化
			+ 没内碎片，可能有外碎片
			+ 克服外碎片的方法：移动进程，内存紧缩
			+ 两种方法跟踪内存使用情况：**位图、空闲链表**
	- 分区的分配算法：
		* 首次适配法：从头查找，找到符合要求的第一个分区
			+ 时间开销大
		* 下次适配法：从上次分配的分区查找，找到符合要求的第一个分区
			+ 较大的空闲分区不易保留
		* 最佳适配法：找到大小和要求相差最小的空闲分区
			+ 容易积累较多小的碎片
		* 最坏适配法：找到最大的空闲分区

#### 11. 如何实现页式存储管理和段式存储管理？页面置换有哪些算法？如何选择页面调入的时机？

+ 简单页式管理：
	- 页的划分由系统自动完成
	- 逻辑页号+页内偏移地址
	- 将物理内存划分成与页大小相同的页框
	- 优点：没有外碎片+程序不需连续存放+便于改变程序占用空间大小
	- 缺点：程序全部装入内存，浪费内存资源
	- 数据结构：进程页表+物理页框表(位图/空闲页面链表)+请求表
	- 硬件支持：内存管理单元
+ 虚拟页式管理：
	- 虚拟页式=简单页式+调页&页面置换
	- 只将当前需要执行的部分页读入内存，并且将内存中暂时不使用的页调出保存在外存上
	- 优点：
		* 可执行较大程序
		* 虚拟内存空间可以大于物理内存
		* 并发：在内存中容纳更多程序并发执行
+ 多级页表：将页表再进行分页，形成二级甚至多级页表
+ TLB快表技术，能够缩短查找时间
+ 页面置换算法：将未来短期不再使用的页面调出
	- 最优页面置换算法：理想情况，选择未来使用时间离当前时间最远的页面进行置换
	- 最近未使用页面置换算法
	- 先进先出算法：选择最老的页面
		* 出现Belady异常：分配页面数增多，缺页率反而提高
	- 第二次机会页面置换算法：最老的页面给第二次机会
	- 时钟页面置换算法：与第二次机会算法等价
	- 最近最少使用算法：LRU算法硬件机构，计数值最小的页面
	- 最不常用算法
	- 老化算法
	- 基于工作集的页面置换算法

	![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P05.png?token=AYGNCLteD7Uwn0EUMlzlIrUkJ6hMZICqks5Zn9jEwA%3D%3D)
+ 工作集：
	- 工作集：进程当前正在使用的页面的集合
		* 工作集逐渐稳定
	- 颠簸：
		* 页面调度时间比进程实际运行时间多，系统效率急剧下降
		* 原因：页面置换算法不好，物理页框数目太少
+ 段式存储管理
	- 段：程序段
	- 简单段式存储管理：
		* 将程序地址空间分层若干段
		* 物理内存管理采用**动态分区**
		* 优点：没有内碎片，外碎片采用内存紧缩
		* 缺点：程序全部装入内存
		* 数据结构：进程段表+系统段表+空闲段表
	- 虚拟段式存储管理：
		* 简单段式+ 调段&段的置换
+ 页式管理与段式管理比较：
	- 分页出于系统管理需要，分段出于用户应用需要
	- 页的大小系统固定，段的大小不固定
	- 分页是一维的，分段是二维的
	- 通常段比页大，段表比页表短，可以缩短查找时间
+ 段页式存储：
	- 页式+段式
	- 段号+页号+页内偏移
	- 虚拟段页式：虚拟段式+虚拟页式

## 文件系统
#### 12. 什么是文件系统？如何实现文件系统？文件系统是否可靠？

+ 文件系统
	- 将信息以文件的形式存储在磁盘或其他介质上
	- 操作系统中处理文件的部分→文件系统
+ 文件系统的功能：
	- 统一管理文件的存储空间
	- 文件的按名存取
	- 文件信息的共享
	- 文件的保护和保密
	- 向用户提供方便使用的接口
+ 文件系统的两种观点：
	- 用户观点：文件的组成、命名、保护，可能进行的操作
	- 系统观点：文件和目录，管理存储空间，文件存储位置
+ 文件：
	- 具有标识符号(文件名)的在逻辑上具有完整意义的信息项的集合
	- 文件体+文件属性
	- 文件的命名规则在不同操作系统上是不同的
+ 文件的逻辑结构：
	- 字节序列：文件是无结构的一串字节的序列
	- 记录序列：文件是一个固定长的记录的序列
+ 文件的类型：
	- 系统文件/库文件/用户文件
	- 临时文件/永久文件/档案文件
	- 只读文件/读写文件/可执行文件
	- 流式文件/记录式文件
	- 顺序文件/链接文件/索引文件
+ 文件的存取：
	- 顺序存取
	- 随机存取：按照关键字
+ 文件控制块：
	- File Control Block, FCB
	- 操作系统为管理文件而设置，存放了管理文件的所有信息
	- FCB是文件存在的标志
+ 目录：
	- 文件目录：所有FCB的有序集合
	- 目录项：可以就是FCB
	- 目录文件：将文件目录以文件的形式存储在外存
	- 简单目录：只引用i节点的目录
+ 目录结构：
	- 一级目录系统
	- 两级目录系统：解决了文件的重名问题，增加了系统开销
	- 层次目录结构
	- 路径名：绝对路径、相对路径
+ 文件系统的实现：
	- 文件系统存放在磁盘：
		* 划分成多个分区
		* 0号扇区称为主引导记录
		* 主引导记录包含分区表
	- 文件的物理结构：
		* 连续分配：
			+ 文件存放在连续的物理块中
			+ 文件不能动态增长
			+ 外部碎片问题
			+ CD-ROM
		* 链表分配：
			+ 充分利用磁盘空间，没有外碎片
			+ 随机访问性能差
		* FAT分配
			+ File Allocation Table，文件分配表
			+ 每个磁盘块的指针字存放在文件分配表中
		* 索引分配
			+ 每个文件有一个专门的数据结构：i节点
			+ i节点(索引节点)，第n个条目指向文件的第n块
			+ 顺序存取 & 随机存取
			+ 增加系统开销，较多寻道次数和寻道时间
+ 共享文件：
	- 硬链接：目录项指向i节点
	- 符号连接：只共享一个路径(快捷方式)，额外开销
+ 磁盘空间管理：
	- 文件存储单位：簇，每个簇包含若干连续扇区
	- 空闲空间管理：空闲快位图、空闲块链表
+ 文件系统的可靠性：
	- 文件备份：
		* 物理转储：输出到磁带
		* 逻辑转储：从特定目录开始
	- 文件系统的一致性
		* 块的一致性
		* 文件的一致性：计数器，从根目录开始检验
+ Windows的文件系统：
	- FAT文件系统
		* FAT12中12表示：单个分区最多存储2^12个簇
	- NTFS：改进的多级目录结构
	- Windows的文件系统驱动程序FSD
+ Linux的文件系统:
	- 虚拟文件系统
	- EXT，可扩展、功能强大的文件系统

## 输入输出I/O

#### 13. I/O设备的组成和分类？端口如何编制？有哪些I/O控制方式？

+ I/O子系统：操作系统中负责管理输入输出设备的部分
+ 设备无关性：设备和系统其他部分之间提供简单的接口，接口对于设备是相同的
+ I/O设备的分类：
	- 按数据的组织方式：
		* 块设备：以数据块为单位
		* 字符设备：以字符为单位
		* 有些设备既不是块设备，也不是字符设备：时钟
	- 按功能特性分：
		* 存储性设备
		* 输入输出型设备
		* 数据通信设备
	- 按资源分配角度：
		* 独占设备
		* 共享设备
+ I/O设备的组成：
	- I/O设备一般由机械(设备本身)和电子(设备控制器)
	- 设备控制器：
		* 完成设备与主机的连接和通信
		* 实现设备内部硬件缓冲、数据加工等功能
		* 寄存器用于与CPU通信：
			+ 控制寄存器
			+ 状态寄存器
			+ 数据缓冲区
+ I/O端口编址及方法：
	- I/O端口地址：每个寄存器有唯一的地址
	- 两种形式：内存映射编址、I/O独立编址
	- I/O独立编址(内存映射I/O)：
		* 每个寄存器被分配一个I/O端口号
		* 缺点：高速缓存，缓存一个设备寄存器是灾难性的
	- 内存映射编址：
		* 将I/O端口看做存储单元，等同于对存储器的编址
		* 所有端口的地址空间与内存的地址空间统一编址
+ I/O控制方式：
	- 程序控制I/O：轮询
	- 中断驱动I/O：
		* 中断寄存器在地址总线上表明哪个设备需要关注
		* 中断向量表存放中断服务程序的入口地址
		* 缺点：中断发生在字符上，浪费CPU时间
	- 直接存储器存取：DMA
		* 数据在内存和I/O设备之间，直接成块传送，包含磁盘地址，内存的起始地址，字节数
	- 中断和DMA的区别：
		* 中断：在数据缓寄存区满之后，中断请求→CPU中断处理
		* DMA：将要传的数据块全传送结束时，要求CPU中断处理，大大减少了CPU中断处理的次数(将中断次数减少到每个缓冲区一次)
	- 通道
		* 完成主存和外围设备间信息的传送，与CPU并行执行操作
		* 将CPU从I/O操作中解放出来
		* 按照信息交换方式和连接设备不同，分类：
			+ 字节多路通道：多个I/O设备
			+ 选择通道：分时地选择高速I/O设备
			+ 数据多路通道：同时多个I/O设备服务
+ I/O的软件原理：
	- I/O软件的目标：
		* 设备独立性
		* 统一命名
		* 错误尽可能在靠近硬件的层面得到处理
		* 同步和异步传输
		* 缓冲技术：无缓冲+单缓冲+多缓冲
		* 共享设备与独占设备
	- I/O软件的层次：
		* 用户进程层：输入输出系统调用
		* 与设备无关的I/O软件：
			+ 设备命名、保护
			+ 缓冲技术，错误报告，分配与释放专用设备
		* 设备驱动程序
		* 中断处理程序
		* 硬件层

#### 14. 典型的输入输出设备有哪些？

+ 磁盘：
	- 优点：
		* 可用存储容量非常大
		* 每位价格非常低
		* 电源关掉后信息不会丢失
	- 磁盘→柱面→磁道→扇区→相同的字节数
	- I/O访问时间：
		* 寻道时间
		* 旋转延迟时间
		* 实际数据传输时间
	- 磁盘臂的调度算法：
		* 目标：减少请求队列对应的平均寻道时间
		* 先来先服务
		* 最短寻道优先
		* 电梯算法：前进方向上移动最少
		* 单向扫描算法
	- 廉价磁盘冗余阵列：
		* 一组较小容量的独立的可并行工作的磁盘
		* RAID：填补了CPU速度快与磁盘设备速度慢之间的间隙
+ 时钟：
	- 定时器，用于维护时间，防止一个进程垄断CPU
	- 时钟软件：设备驱动程序
	- 类型：
		* 简单时钟
		* 可编程时钟
			+ 晶体振荡器(石英)、计数器、存储计数器
			+ 操作模式：一次完成、方波
			+ 优点：中断频率可由软件控制
+ 终端：
	- 终端软件：
		* 输入软件：键盘
		* 输出软件：显示驱动