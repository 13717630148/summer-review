# 操作系统 知识梳理

## 引论概述

#### 1. 计算机系统的组成？为什么引入操作系统？什么是操作系统？操作系统有哪些功能和作用？操作系统的硬件环境？

+ 计算机组成：
	- 硬件：物理设备的有机组合，系统赖以工作的实体
	- 软件：程序和文件的集合。程序是计算任务的处理对象和处理规则的描述；文件是需要的资料数据
+ 引入操作系统的原因：
	- 计算机硬件复杂，直接对硬件编程不现实
+ 操作系统的定义：
	- 最基本的系统软件

	![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P01.png?token=AYGNCH03C4TceOmOJYkVfEkBV6gbhMhLks5Znr3bwA%3D%3D)

	- 特点：
		* 有效：系统效率和资源利用率
		* 合理：是否公平
		* 方便：提供良好的、一致的用户接口
+ 操作系统的功能：
	- 将硬件的复杂性与程序分离
	- 在裸机上加载一层软件，给用户提供更容易理解和编程的接口
	- 控制计算机的所有资源，提供开发应用程序的基础
+ 操作系统的作用：
	- 扩展机器或虚拟机，更容易编程和使用
	- 资源管理者，管理CPU、存储器、外部设备等
		* 跟踪资源使用状况
		* 满足资源请求
		* 提高资源利用率
		* 协调各程序和用户对资源的使用冲突
	- 用户使用计算机软硬件的接口
		* 系统命令
		* 系统调用
+ 操作系统的历史：
	- 电子管时代
	- 晶体管时代
		* 批处理操作系统
	- 集成电路时代
		* 多道程序设计：宏观并行微观串行
		* 分时系统
		* 系列机思想
	- 大规模集成电路时代
		* 个人计算机操作系统
		* 分布式操作系统
		* 嵌入式操作系统：对嵌入式芯片及各种资源同一协调、控制
+ 操作系统的硬件环境：
	- 处理器
		* 运算器、控制器、寄存器和高速缓存
		* 取指、译码、执行
		* 核心态和用户态：
			+ 核心态：操作系统管理程序运行
			+ 用户态：用户程序运行时的状态
		* 处理器如何知道当前运行的是操作系统还是一般软件：
			+ CPU的工作状态码
		* CPU状态的转换：
			+ 用户态→核心态：嵌入
			+ 核心态→用户态：修改程序状态字
	- 存储器
		* 存储程序和数据
		* 三因素：容量、速度和成本
		* 层次化存储体系结构+局部性原理
	- I/O设备
		* 控制器+设备
		* 设备驱动程序：专门与控制器对话
		* 编址方式：存储映像编址、IO独立编址
		* 控制方式：轮询、中断驱动IO、直接存储器访问(DMA)
		* 中断响应：

		![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P02.png?token=AYGNCCAlkq7Lq3jM69F52J2hCP0QmI_fks5Znr3qwA%3D%3D)

		* 中断提高处理器处理IO的效率，但是传送大量数据时效率仍不高
		* DMA控制器自动控制成块数据在内存和IO设备间的传送
	- 总线


#### 2. 系统调用？
+ 意义：
	- 方便用户编写应用程序
	- 在应用程序与系统控制的资源和提供的服务间实现交互作用
	- 动态请求和释放系统资源，完成与硬件相关的工作和控制程序的执行
+ 系统调用的处理过程：
	- 陷入指令
		* 将系统转入核心态
		* 陷入指令中包含对应系统调用的功能号
		* 陷入处理机构将陷入指令功能号与入口地址表对应，调用有关子程序
	- 过程：
		* 系统调用处理前，陷入处理机构保护处理现场
		* 陷入指令调用系统功能
		* 系统调用的功能号驱动有关子程序执行
		* 执行结束后恢复处理机现场，保护在特定内存区或寄存器


#### 3. 操作系统结构有哪些类型？
+ 单体系统
	- 优点：结构紧密，接口简单直接，系统效率高
	- 缺点：
		* 模块间转接随便
		* 数据基本上作为全程量处理
		* 常常关中断，系统的并发性难以提高
+ 分层系统
	- 分解成功能单一的模块，各之间有清晰的组织结构和依赖关系
	- 优点：
		* 更高的可读性和可适应性
		* 便于修改扩充
+ 虚拟机结构
+ 微内核结构：
	- 微内核：运行在核心态下，提供最基本的中断处理、处理机调度、进程间通信功能
	- 优点：机制与策略分离，可靠灵活
	- 缺点：效率低
	- 变体：客户-服务器模型


## 进程与线程

#### 4. 进程的定义和描述？进程的状态有哪些？

+ 程序的顺序执行和并发执行
	- 顺序执行：
		* 顺序性：指定顺序
		* 封闭性：独占所有资源
		* 可再现性：初始条件相同则结果相同
	- 并发执行：提高资源利用率，目前主流操作系统为并发执行
		* 间断性
		* 失去封闭性：共享资源
		* 失去可再现性
+ 进程的引入：为了跟踪与描述程序的并发执行
	- 目的：
		* 为了描述程序在并发执行时对系统资源的共享
		* 描述程序执行时的动态特征
		* 提高资源利用率和系统吞吐量
	- 并发执行的程序：
		* 一个程序在不同数据上的执行
		* 不同程序在不同数据上的执行
+ 进程：
	- 系统进行资源分配和调度的独立单位
	- 特征：
		* 动态性
		* 独立性：地址空间相互独立
		* 并发性
		* 异步性
		* 交互性
		* 结构化
	- 进程的组成：程序+数据+进程控制块
	- 进程与程序的区别

	![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P03.png?token=AYGNCCosY3DSpzWFEWgzyjnKA6FwXyk0ks5Znr0kwA%3D%3D)

+ 进程控制块：
	- Process Control Block, PCB
	- 目的：为了控制和管理进程，用来记录进程外部特征
	- 进程与PCB之间一一对应
	- PCB包含的内容：
		* 描述进程的信息
		* 用于控制进程的信息
		* 资源占用的信息
		* CPU现场保护的信息
	- PCB表：进程表
		* 将所有PCB组织在一起
		* 表的大小决定了系统中最多可能存在的进程个数**系统的并发度**
	- PCB表组织方式：
		* 链接结构
		* 索引结构
+ 进程上下文：对进程执行活动全过程的静态描述
	- 用户级上下文
	- 寄存器级上下文
	- 系统级上下文
+ 进程的状态
	- 三状态模型：运行、就绪、阻塞
	- 五状态模型：+ 新建、终止
	- 七状态模型：五状态模型+就绪挂起+阻塞挂起
		* 挂起：将进程从内存转到外存
	- 补充：Linux五中进程状态
		* 可运行态+浅度睡眠态+暂停状态+僵死状态
+ 进程的控制
	- 定义：操作系统创建和撤销进程，完成进程状态的转换
	- 目的：多个进程高效率并发执行和协调，实现资源共享
	- 方式：根据用户命令和系统的状态
	- 原语：
		* 若干指令构成的原子操作，不可分割
		* 系统调用不都是原语
		* 类型：创建、终止、撤销、阻塞、唤醒等原语

#### 5. 线程和线程的实现机制？

+ 引入线程的目的：
	- 减少程序并发执行付出的时空开销，进一步提高系统并发程度
+ 进程的基本属性(并发执行的基础)：
	- 资源分配单位
	- CPU调度单位
+ 进程的缺点：
	- 系统对进程的时空开销较大
	- 系统中并发执行的进程的数目不宜过多
	- 继承切换速率不宜过高，限制了系统的并发程度
+ 改进进程的缺点：将两个基本属性分离：
	- 进程：只作为资源分配的单位
	- **线程**：作为CPU调度的单位
	- 线程有时被称为轻量级进程
+ 线程的组成：
	- 线程状态、寄存器上下文、线程的栈
	- 基本状态：就绪、运行、阻塞
+ 多线程：同一个进程中允许多个线程
	- 线程共享进程的地址空间和资源
	- 同一进程的每个线程有自己的栈
+ 引入线程的优缺点：
	- 优点：
		* 减少并发执行时间和空间开销
		* 允许在系统中建立更多的线程提高并发程度
		* 同一进程的线程共享内存和文件，相互通信无须调用内核
	- 缺点：在程序设计模型中引入了一定的复杂度
+ 进程与线程比较：
	- 地址空间和其他资源：
		* 进程：进程之间相互独立
		* 线程：同一进程的线程之间共享
		* 某进程的线程在另一进程中不可见
	- 通信：
		* 进程间通信
		* 线程之间：直接读写
	- 调度：
		* 线程上下文切换 快于 进程上下文切换
+ 线程的实现机制：
	- 用户级线程
		* 操作系统内核不知道用户级线程的存在
		* 用户级线程切换不需要核心态特权
		* 每个进程有专用的线程表，记录各线程状态和属性
		* 线程表由线程库(运行时系统)管理
		* 用户级线程的内核活动
			+ 调用系统调用时，线程所在的整个进程阻塞
			+ 线程的状态与进程状态是独立的
		* 优点：
			+ 不需要调用操作系统内核
			+ 调度是应用程序特定的
		* 缺点：
			+ 大多数系统调用阻塞，因而内核阻塞进程后，所有线程都被阻塞
			+ 同一进程的两个线程不能同时运行于两个处理器
	- 内核级线程
		* 操作系统内核维护内核级线程上下文
		* 内核级线程切换需要操作系统内核支持
		* 没有线程库，所有内核级线程由操作系统内核管理，不需要线程库和线程表
		* 内核级线程的调度以线程为基础
		* 优点：
			+ 内核可以同时调度同一进程多个线程
			+ 阻塞是在线程一级完成的
		* 缺点：
			+ 同一进程内的线程切换需要操作系统内核支持，这会导致速度的下降
	- 内核级和用户级混合
		* 将用户级线程与内核级线程多路复用
+ 线程的状态：
	- Windows：就绪、备用、运行、等待、过渡、终止、初始化
	- Linux：只有进程没有线程概念，线程=共享资源的进程


#### 6. 进程之间如何通信？
+ 进程间的关系：
	- 竞争：相互竞争系统中有限的资源
	- 同步：相互协作运行用户的作业
	- 通信：通过通信进行协作
+ 进程间通信问题：
	- Inter Process Communication, IPC
	- 1. 一个进程如何把信息传递给另一个进程
	- 2. 保证对共享资源的访问不会引起冲突
	- 3. 保证正确的操作顺序
	- 总结为：**高级通信问题+互斥与同步问题**
+ 进程间通信的关键：
	- 竞争条件：多个进程访问共享资源时取决于进程运行的时序
	- 临界资源：多个进程访问共享资源时必须互斥地进行
		* 不是所有共享资源都是临界资源，如只读数据
	- 临界区：进程中访问临界资源的代码段
		* 进入区→临界区→退出区→剩余区
+ 解决互斥问题：
	- 要求：
		1. 任何两个进程不能同时处于临界区 
		2. 不应对 CPU 的速度和数量做任何假设
		3. 临界区外运行的进程不得阻塞其他进程
		4. 不得使进程无限期等待入临界区
	- 目的：
		- 避免竞争条件
		- 保证使用临界资源的进程能正确高效地协作
+ 解决互斥问题的方法/算法：
	- 禁止中断：
		* CPU只有在时钟中断或其他中断时才进行进程切换
		* 所以在进入临界区之后禁止中断，就无法进行进程的切换，保证互斥
		* 优点：简单
		* 缺点：
			+ 把禁止中断的权利交给用户进程→系统可靠性较差
			+ 不适用于多处理器
	- 锁变量：
		* 用一个变量表示是否有进程在临界区
		* 缺点；忙等待，可能出现两个进程同时处于临界区
		* 忙等待：连续测试一个变量，直至出现某个值
	- 严格轮转法：记录哪个进程进入临界区
		* 缺点：临界区外进程可能阻塞其他进程，忙等待
	- Peterson算法：
		* 进入临界区前，调用一个函数，判断是否能安全进入
		* 从临界区退出后，调用退出函数，允许其他进程进入临界区
		* 优点：解决互斥访问的问题，克服了严格轮转法缺点
		* 缺点：忙等待
	- 硬件指令算法：
		* 优点：
			+ 适用于任意数目的进程
			+ 容易验证正确性
			+ 支持进程中存在多个临界区，每个临界区设置一个布尔变量
		* 缺点：忙等待
	- 信号量：
		* 高于进程的管理者，解决共有资源使用问题
		* 每个信号量包含一个整数值和一个进程等待队列
		* P、V原语：P申请一个资源，V释放一个资源，PV必须成对使用
		* 为临界资源设置一个互斥信号量，临界区代码位于P和V原语之间
		* 缺点：
			+ 同步操作分散
			+ 易读性差
			+ 不利于修改和维护
			+ 正确性难以保证
	- 管程：
		* 基本思想：把信号量和操作原语封装在一个对象内部
		* 管程的共享变量在管程外部不可见
		* 优点：
			+ 提高代码可读性
			+ 便于修改和维护
			+ 正确性易于保证
		* 缺点：C及多数语言不支持管程
	- 消息传递：
		* 不同机器间的进程通信
		* 经典IPC问题：
			+ 哲学家进餐
			+ 读着写者
			+ 睡眠理发师
+ Windows的互斥和同步机制：
	- 互斥对象：Mutex
	- 信号量对象：Semaphore
	- 事件对象：Event
	- 临界区对象
	- 互锁变量访问
+ POSIX的互斥和同步机制：
	- 互斥锁
	- 条件变量
	- 信号量
+ Linux进程间通信
	- 管道(无名管道/匿名管道)
		* 进程之间相互通信，通常需要两个管道
		* 命名管道，首先写入数据的是首先被读出的数据
	- 消息队列
	- 信号量
	- 共享内存
+ Windows进程间通信：
	- 共享内存
	- 管道
	- 邮件槽mailslot
	- 套接字

#### 7. 什么是死锁问题？如何解决死锁问题？
+ 死锁：系统中多个进程无限制地等待永远不会发生的条件
+ 原因：
	- 对互斥资源的共享
	- 并发执行的顺序不当
	- 双方在同时等待
		1. 对方已经占有的资源
		2. 对方生成资源
	- 必要条件(死锁一定同时满足四个条件)
		1. 互斥
		2. 请求和保持
		3. 非强制剥夺
		4. 环路等待
+ 可抢占资源：存储器/不可抢占资源：打印机
+ 解决死锁问题的方法：
	- 鸵鸟算法：假装危险不存在
	- 死锁预防：预先静态分配、**有序**资源使用
	- 死锁检测：检测是否存在**循环等待**
	- 死锁避免：
		* 银行家算法

#### 8. 处理机调度是什么？不同的系统如何实现调度？
+ 调度：多个进程竞争处理机资源，操作系统选择给哪一个进程分配处理器
+ 处理器调度的层次：
	- 高级调度：作业
	- 中级调度：内外存交换
	- 低级调度：进程或线程
+ 进程调度的算法
	- 批处理系统
		* 目标：吞吐量、周转时间、CPU利用率
		* 先来先调度：有利于长作业、CPU密集作业
		* 最短作业优先：不利于长作业
		* 最短剩余时间优先：有利于短作业
	- 交互式系统
		* 目标：响应时间、均衡性
		* 时间片轮转：所有进程同等重要的假设
		* 优先级调度
		* 多级队列：高优先级队列时间片短
		* 最短进程优先
		* 保证调度：保证**进度慢**的进程
		* 彩票调度：随机选择有彩票的进程
		* 公平分享调度：按进程数对用户调度资源
	- 实时系统
		* 满足截止时间、可预测性
			+ 硬实时、软实时
		* 可调度的条件
		* 速率单调调度：调度优先级最高，必要时剥夺进程
		* 最早截止时限优先
		* 最小裕度算法：选富裕时间最小的
+ 进程调度的时机

![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/05-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/figures/P04.png?token=AYGNCBvuaNSWaFY3TVJxxJaZiA2UlfGIks5Znr0_wA%3D%3D)

+ 线程的调度：
	- 用户级：由用户级线程库的线程调动程序负责
	- 内核级：由内核选择，不考虑线程属于哪个进程