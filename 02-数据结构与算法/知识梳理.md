# 数据结构与算法复习 知识梳理

## 数据结构

#### 1. 顺序表及链表

+ 线性表特点：
	- 线性表数据元素必须满足```同质性```
	- 相邻元素之间存在有序关系```位序```
+ 顺序表：线性表的顺序存取
	- 主要操作：
		* 插入：移动元素次数的期望为n/2
		* 删除：移动元素次数的期望为(n-1)/2
	- 需要注意的问题：
		* 边界判断
		* 存在性判断
		* 溢出判断
	- 特点：
		* 可以随机存取元素
		* 插入和删除时需要移动大量元素
		* 需要事先确定数据的规模，空间效率不高
+ 链表：链式存储结构
	- 特点：
		* 逻辑上相邻的元素在物理地址上不需要相邻
		* 依靠指针连接逻辑上相邻的元素
	- 单向链表
		* 链表结点：由数据域和指针域构成
		* 主要操作：
			+ 插入：O(n)
			+ 删除：O(n)
		* 优点：
			+ 插入和删除操作无需移动数据元素
			+ 空间利用率高
		* 缺点：
			+ 不能随机存取
			+ 表长需要遍历链表得到
			+ 插入或者删除需要在链表中寻找操作位置
	- 双向循环链表
		* 缺点：双向循环链表的插入和删除需要修改两个方向的指针

#### 2. 栈与递归

+ 基本概念： 
	- 栈的定义：只允许在一段进行插入和删除操作的线性结构
	- 栈顶：允许插入和删除的一端
	- 栈底：线性结构的另一端
	- 栈长：数据元素的个数
	- FILO == LIFO
+ 顺序栈：
	- 地址连续
	- 时间复杂度：进栈、出栈和销毁时间复杂度都是O(1)
	- 空间复杂度：预先设置栈的长度，空间利用效率低
+ 链式栈：栈的链表表示
	- 地址任意
	- 时间复杂度：进出栈O(1)，销毁O(n)
	- 空间复杂度：一般不溢出，空间利用率高
+ 栈的应用：
	- 显式：括号匹配、表达式求值(前缀、中缀、后缀表达式)、迷宫求解
	- 隐式：函数调用、递归
+ 递归：直接或间接调用本身
	- 递归的消除：
		* 目的：提高时间和空间效率
		* 递推法实现递归的消除
		* 很多情形必须调用```显式```的栈实现非递归
	- 实际应用：阶乘求值、最大公因子、斐波那契数列、汉诺塔问题
	- 递归的优势：便于叙述和设计，算法简洁易理解
	- 递归的缺点：降低了运行效率


#### 3. 队列

+ 基本概念
	- 队列：在表的一端进行插入(入队)，在另一端进行删除(出队)
	- 队尾：允许插入的一端
	- 队头：允许删除的一端
	- 队列的特点：先进先出(FIFO)
+ 队列的分类：
	- 循环队列：可以将队列看成一个圆形队列
	- 链式队列：队头在链表头，队尾在链表尾
+ 队列的应用：
	- 缓冲技术：提高设备利用率，改善不同设备间速度不匹配
		* 单缓冲
		* 双缓冲
		* 缓冲队列
 
#### 4. 串与字符串

+ 对"串"的理解
	- 有限长度的字符序列
	- 限定数据元素为字符的线性表
+ 基本概念
	- 子串：串中人一多个```连续```字符组成的子序列
	- 主串：包含该子串的串成为主串(相对于子串而言)
+ 串匹配算法
	- 目的：已知目标串和模式串，需要在目标串中找到一个与模式串相同的子串(又称为模式匹配或者子串定位)
	- 应用：文本编辑、程序调试、搜索引擎、生命科学
	- 蛮力算法
		* 说明：每次移动一个字母，并且逐个字母匹配
		* 时间复杂度：O(n*m)
		* 优点：直观，实现起来很简单
		* 缺点：算法效率过低，只适用于解决小规模问题
	- KMP算法
		* 说明：自左向右匹配，匹配过程中，出现不匹配情况，应尽量向右移动最大距离，避免重复。
		* KMP算法需要进行预处理，逐个位置求出部分匹配串
		* 时间复杂度：O(m+n)
	- Boyer-Moore算法
		* 基础：Horspool算法
		* 预处理：Last-Occurenceh函数，记录每个字母在模式串中出现的最后的位置
		* 时间复杂度：最坏情况下O(n*m+s)；恒定数目匹配O(n)

#### 5. 树与二叉树

+ 基本概念
	- 树的定义：
	由n个结点(node)组成的有限集合。其中有一个根结点(root node)，只有直接后继，没有直接前驱。
	- 结点：
		* ```结点```：数据元素，并且指向树的分支
		* ```结点的度```：结点的子树个数(分支结点度不为0，叶子结点度为0)
		* ```树的度```：树中结点的度的最大值。若最大值为k.则该树为k叉树
		* ```孩子(child)结点```：某个结点A的子树的根结点为B，则B为A的子结点，A为B的```双亲(parent)结点```或者父结点
		* ```兄弟(sibling)结点```：具有相同双亲结点的结点
		* ```堂兄弟(cousin)```：某结点的不同子树的根结点的孩子结点
		* ```祖先(ancestor)```：从根节点到某个结点A的路径上的所有结点称为结点A的祖先，某结点中所有子树的结点称为该结点的```子孙(descendant)```
	- 树的基本术语：
		* 结点的层次：根结点层次为1，第i层结点的子树的根结点的层次为i+1
		* 树的深度(高度)：树中叶子结点所在的最大层次
+ 树的一些性质
	- 树中结点数目等于所有结点的度数和加1
	- 度为k的树中，第i层上至多有k^(i-1)个结点
	- 深度为h的k叉树至多有(k^h - 1)/(k - 1)个结点
	- 具有n个结点的k叉树的最小深度为log_k(n*(k-1)+1)
+ 二叉树：k = 2时的k叉树
	- 二叉树的性质

	![image](https://raw.githubusercontent.com/charlesliucn/summer-review/master/02-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/figures/P1.png?token=AYGNCGr-UFaTqNU75AbQmW5a8e13WIAcks5Zm4jnwA%3D%3D)

	- 二叉树的表示
		* 空间占用：
			+ k层二叉树需要2^k-1个存储单元。
			+ 空间效率：不完全二叉树，结点越少，空间效率越低、
		* 二叉树的链式表示：
			+ 数据域和指针域(两个指针分别指向左子树和右子树)
	- 二叉树的遍历
		* 定义：按照某种次序访问树中的结点，每个结点访问一次且仅访问一次
		* 遍历次序：
			+ 先序(根结点-左-右)
			+ 中序(左-根结点-右)
			+ 后序(左-右-根结点)
			+ 层序(从低到高逐层遍历，每层从左往右)
	- [二叉搜索树](http://blog.csdn.net/jiqiren007/article/details/6534810)
+ Huffman(霍夫曼)树
	- 基本概念：
		* 分支：两结点之间的"线段"部分
		* 路径：结点到结点的分支
		* 带权路径：对分支加权的路径
		* 路径长度：路径上的分支数
		* 结点的(加权)路径长度：从根结点到该结点的路径上的(带权)路径长度
		* 树的(加权)路径长度：从根结点到所有叶子结点的(带权)路径长度之和
	- 霍夫曼树
		* 定义：所有路径长度相同的二叉树中，带权路径长度最小的树，也称为最优二叉树。
		* 特点：权值大的结点离根结点更近。
	- [霍夫曼树的构造](http://blog.csdn.net/sddxqlrjxr/article/details/51114809)
	- 霍夫曼编码
		* 平均编码长度较短的编码方案具有更好的性能
		* 变长编码：出现概率大的字符，编码短一些；概率小的编码长
		* 霍夫曼编码：[构造霍夫曼树](http://blog.csdn.net/sddxqlrjxr/article/details/51114809)，是一种最优编码
		* 缺点：
			+ 霍夫曼码会有错误传播，无法查错和纠错
			+ 需要精确获得文本字符出现的概率


#### 6. 优先级队列

+ 与普通队列的区别：
	不再遵从FIFO原则，而是每次从队列中取出具有最高优先权(优先级)的队列
+ 优先级队列的应用场景：
	- 线程优先级
	- 斯诺克台球
	- 银行贵宾卡服务
	- Windows消息队列
	- 个人事务处理
+ 优先级队列的实现方式及时间复杂度分析
	- 基于无序顺序表
		* 插入：O(1)
		* 取出最高优先级元素：O(N)
		* 删除整个队列：O(N)
		* 改变某个元素优先级：O(1)
	- 基于有序顺序表
		* 插入：O(N)
		* 取出最高优先级元素：O(1)
		* 删除整个队列：O(N)
		* 改变某个元素优先级：O(N)
	- 基于无序链表
		* 插入：O(1)
		* 取出最高优先级元素：O(N)
		* 删除整个队列：O(N)
		* 改变某个元素优先级：O(1)
	- 基于无序链表
		* 插入：O(N)
		* 取出最高优先级元素：O(1)
		* 删除整个队列：O(1)
		* 改变某个元素优先级：O(N)
	- 基于堆
+ 堆
	- 定义：满足堆性质的**完全二叉树**
	- 分类：
		* 最大堆：父结点值较大，堆顶结点值最大
		* 最小值：父结点值较小，堆顶结点值最小
	- 存储方式：
		顺序存储于一维数组
	- 堆的高度：堆顶结点的高度
	- 堆的操作
		* 插入(堆的建立)
		新结点加入到堆尾，自底向上堆化(自顶向下的堆构造)，时间复杂度小于O(NlogN)
		自底向上的堆构造：O(n)，线性复杂度	

		* 删除：
		将堆顶结点删除，将堆尾结点放到堆顶，通过自顶向下堆化修复

		* 堆的修复：
		以最大堆为例：
			结点大于父结点：自底向上
			结点小于子结点：自顶向下
		* 时间复杂度：自底向上、自顶向下都是O(h)
		* 空间复杂度：堆化操作都是本地操作，基本不需要辅助空间
+ 堆与优先级队列
	- 堆是实现优先级队列的主要数据结构之一
	- 时间复杂度分析
		* 插入操作：O(logN)
		* 删除操作：O(logN)
		* 取最高优先级：O(1)
		* 修改元素优先级：O(logN)
	- 结论：堆是一种高效算法